---
layout: post
title:  "컴포넌트 단위의 개발"
author: 악어새62
categories: [ TIL, WEB, Frontend]
image: assets/images/4.jpg
tags: [바닐라 JS, Web, Frontend]
---
## 개요

처음 프론트앤드를 배우면 보통 각 페이지에 해당하는 html파일을 만들고 사용한다.  
그러나 이런 생각을 해볼수도 있다.  
자바스크립트는 페이지를 동적으로 조작하기 위해 사용한다. 즉, 자바스크립트를 통해서 요소를 만들고 삭제하는등의 작업이 가능하다.  
그렇다면 화면을 각 부분으로 분리해서 관리한다면 좀 더 스마트하게 작업할 수 있지 않을까?

만약 페이지의 어떤 부분을 수정하고싶다면 그 부분을 렌더링하는 자바스크립트 부분을 손보면 된다.  
이것이 바로 리엑트나 뷰같은 프론트 개발 툴의 기본 원리다.  

## 개념

프론트엔드에서 중요한 개념중 하나가 바로 템플레이팅이다. 우리가 웹 사이트를 보면 실제 데이터는 서버에서 전송되고 이 데이터를 프론트엔드에서 만든 html에 끼워 넣는다. 이런 작업을 템플레이팅이라고한다.

자바스크립트의 템플레이팅 라이브러리중 유명한 것이 바로 Handlebars라는 라이브러리다.  
데이터를 끼워넣을 비어있는 html 코드 뭉치를 만들고 데이터와 함께 컴파일한다.   
그럼 완성된 html코드를 리턴하고 타겟 html.innerHtml을 사용하여 넣어주면 된다.

처음에는 템플릿 함수를 하드코딩해서 정의하고 사용했었다. 그러니 템플레이팅해야하는 부분이 많아지면 그만큼 비슷한 코드를 정의해서 사용해야했다.  
그러다 생각이 든게 함수에서 동적으로 바뀌는 부분을 인자로 받아서 사용하는 것이었다.  
인자로는 템플레이팅하기위한 데이터와 타겟 html을 넣어서 사용했었다.

이런 아이디어를 활용해서 이번에는 각 부분을 컴포넌트화해서 사용하는 방법을 생각해볼 수 있다.  
요소를 화면에 표현하는 함수를 하나 만들고서 여기에서 화면을 만들고 렌더링하는 것이다. 

## 모듈

자바스크립트에서도 다른 프로그래밍언어와 마찬가지로 패키지를 나누고 import해서 사용하는 방법이 생겼다.  
ES2015에 추가된 개념으로 import와 export를 통해 다른 파일에서 사용할 수 있다.  
예를 들어 하나의 자바스크립트 파일에서 다음과 같이 사용할 수 있다.  
```js
// sample.js
const sample = 'sample value';

export { sample };
```
하나의 모듈에서 export하고
```js
// main.js
import { sample } from './sample.js'

console.log(sample); // 'sample value'
```
다른 모듈에서 import해서 사용한다.

위에서는 하나의 값을 내보내기해서 사용했고 `export default`구문을 사용해서 모듈을 대표하는 값을 지정하고 사용할 수 있다.

```js
//sample.js
export default 'sample value';
```
```js
import { sample } from './sample.js'

console.log(sample); // 'sample'
```

## Let's get started!!

기본환경 셋팅
```shell
npm init -y
npm i parcel -D
```
```json
// package.json
"scripts": {
  "dev": "parcel ./index.html",
  "build" : "parcel build ./index.html"
},
```

index.html 파일을 만들어주고 id가 root인 div요소를 하나 만들어주고 js모듈을 연결한다.
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script type="module" src="./src/main.js" defer></script>
</head>
<body>
  <div id="root"></div>
</body>
</html>
```
프로젝트의 핵심 기능을 하는 모듈을 작성해준다.
```js
// Component
export class Component {
  constructor(payload = {}) {
    const { tagName = 'div' } = payload;
    this.el = document.createElement(tagName);
    this.render();
  }
  render() {
    //... 
  }
}
```
클래스를 하나 정의하고 생성자에서 태그의 이름을 받은다음 요소를 생성한다.

이걸 사용할 모듈에서는 다음과 같이 작성해준다.
```js
import { Component } from './core/Main'

export default class App extends Component {
  constructor() {
    super();
  }
  render() {
    this.el.innerHTML = `
      <h1>Hello world</h1>
      <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Ratione voluptate consequatur voluptates ipsa velit repudiandae, consectetur tempore perferendis, distinctio odit ab vel illo illum fugiat a accusamus, ullam facere! Sapiente.</p>
    `
  }
}
```
import 키워드를 통해 모듈을 가져오고 상위 클래스에서 결정하기 어려운 render함수의 내용을 하위 요소에서 결정한다.

이번에는 어떤 버튼을 눌렀을 때 input요소의 값을 콘솔에 출력하도록 해보자.
```js
import { Component } from './core/Main'

export default class App extends Component {
  constructor() {
    super({
      state : {
        inputText: ''
      }
    });
  }
  render() {
    this.el.classList.add('search');
    this.el.innerHTML = `
      <input /><br>
      <button>click me</button>
    `;

    const inputEl = this.el.querySelector('input');
    inputEl.addEventListener('input', () => {
      this.state.inputText = inputEl.value;
    });

    const buttonEl = this.el.querySelector('button');
    buttonEl.addEventListener('click', () => {
      console.log(this.state.inputText);
    });
  }
}
```
내부에서 input태그의 값을 저장하기위해서 state라는 객체를 만들었다.
```js
export class Component {
  constructor(payload = {}) {
    const { tagName = 'div',
      state = {}
    } = payload;
    this.el = document.createElement(tagName);
    this.state = state;
    this.render();
  }
  render() {
    //... 
  }
}
```
이렇게 선언해서 렌더링하는 것을 선언적 렌더링이라고 부른다.

참고로 이벤트중 요소에 변경을 감지하는 이벤트는 input과 change가 있다. 이 둘은 비슷해보이지만 살짝 다르다.  
input이벤트는 입력창에 입력을 했을 때 실시간 검색어 추천 기능과 같이 input창에 값이 변경될 때 발생하고 change는 체크박스와 같은 경우 요소 변경이 일어났을 때가 아닌 포커스를 벗어날 때 이벤트가 발생한다. 그래서 input요소에 텍스트로 입력할 경우 요소가 계속 작성되고있기때문에 change이벤트가 아닌 input요소를 사용해야한다.