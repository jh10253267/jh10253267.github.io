---
layout: post
title:  "탐색"
author: 악어새62
categories: [ TIL, Algorithm ]
image: assets/images/2.jpg
tags: [ 파이썬, 코딩테스트 ]
---
## 개요

공부한 걸 내 것으로 만들려면 정리하는 시간이 필요하다!

## 알고리즘 설명

탐색이란 그래프 완전 탐색 기법중 하나로 많은 양의 데이터 중에 원하는 데이터를 찾는 과정을 말한다.  
탐색의 대표적인 문제는 게임 지도가 주어지고 경로를 탐색해서 가장 최단 경로를 찾는 문제로 프로그래머스의 게임 맵 최단거리가 있다.

수학시간에 배웠던 순열과 조합에서 4 * 3 격자가 있고 특정 위치에서 목표까지 가는 경우의 수를 구하는 문제는 최단 경로를 찾는 것과 경우의 수를 찾는 스텝으로 나뉜다.  
최단 경로를 구하려면 오른쪽 화살표 4번과 아래 화살표 3번의 순서를 정하면 해결되었던 것을 떠올렸지만 입력으로 주어진 지도가 다양했고 왼쪽 위에서 시작하지만 내려갔다가 다시 위로 올라가는 등 일반화시키기 어려웠다.

해결 방법은 마치 시뮬레이션을 돌리듯이 가능한 경로를 탐색하고 최단 경로를 구하면 된다.

## 사전지식

### 스택

스택이란 창고에 물건을 하나씩 쌓는 것과 같다.  
가장 밑에 있는 물건을 사용하려면 가장 위에있는 것 부터 치워야한다. 이러한 구조를 선입후출이라고 한다.

예를 들어 스택 자료구조에 5,4,3,2,1을 넣고 하나씩 꺼낸다면 1,2,3,4,5의 순서로 출력된다.

파이썬에서는 별도의 라이브러리를 사용하지 않아도 기본 리스트를 사용하면 스택과 동일하게 사용이 가능하다.
* append - 리스트의 가장 마지막에 요소를 추가함
* pop - 리스트의 가장 마지막에서 하나를 반환함

### 큐

큐는 종이컵 디스펜서와 같다. 위쪽에서 종이컵을 넣고 아래쪽에서 종이컵을 꺼내서 쓴다.(굳이 위에서 꺼내쓰는 별난 사람들은 예외로 치자.)  
이런 구조를 선입선출이라고 부른다.

예를 들어 5,4,3,2,1을 넣고 출력한다면 5,4,3,2,1의 순서로 출력된다.

파이썬에서 큐는 collections라이브러리의 deque를 사용한다. 스택과 큐의 장점을 가지고있고 속도가 빠르다.
```python
from collections import deque

queue = deque()

queue.append(5)
queue.append(4)
queue.append(3)
queue.append(2)
queue.append(1)

queue.popleft()
print(queue) # deque([4,3,2,1])
```

### 재귀

자기 자신을 호출하는 것을 말한다.  
```plain
내가 옛날이야기 하나 해주마
옛날 어느 산에 신선이 살았단다.
그 신선이 말하기를 "내가 옛날 이야기 하나 해주마"
"옛날에 어느 산에 신선이 살았단다"
"그 신선이 말하기를"
...
```

팩토리얼을 생각해도 되겠다.
```python
def factorial(n):
  if n <= 1:
    return 1
  return n * factorial(n-1)

factorial(5) # 120
```

## 탐색 문제풀이

### 프로그래머스 이웃한 칸

색깔을 담은 2차원 배열이 주어지고 배열의 특정 인덱스가 주어져서 타겟 칸의 색과 일치하는 색이 상하좌우에 몇 개가 있는지 구하는 문제  
h, w는 각각 y축과 x축에 해당한다.  
board의 길이 즉 행의 갯수는 1보다 크거나 같고 7보다 작거나 같다.  
board의 열의 갯수는 1보다 크거나 같고 10보다 작거나 같다.

즉, y의 길이는 최대 7이고 x의 길이는 최대 10이된다.

* 타겟 색깔을 구한다.
* 타겟 색깔의 칸으로부터 상하좌우를 탐색한다.
* 만약 인덱스가 범위안에 있고 타겟 색과 일치하면 count를 증가시킨다.
```python
def solution(board, h, w):
    answer = 0
    dh = [1, -1, 0, 0] # 상하
    dw = [0, 0, 1, -1] # 좌우
    target = board[h][w]

    for i in range(len(dh)):
      h_check, w_check = h + dh[i], w + dw[i]

      if 0 <= h_check < len(board) and 0 <= w_check < len(board[0]):
        if board[h_check][w_check] == target:
          answer += 1

    return answer
```
주의해야할 점은 for 반복문은 상하좌우 한 칸씩만 이동하기 때문에 len(dh) 혹은 len(dx)를 조건으로 넣어야하고 마지막에 답을 구할 때는 board상의 y인덱스인 h_check와 x인덱스인 w_check가 유효한지 체크해야하기 때문에 board의 가로와 세로 길이를 넣어줘야한다는 것이다.

## DFS

위의 문제는 프로그래머스에서 탐색 문제의 맛보기 식으로 준비한 문제라고 생각한다.  
이처럼 레벨 1문제는 알고리즘을 몰라도 풀 수 있는 문제들이 많고 알고리즘에 대해 찾아보고 공부할 수 있는 문제들이 많다.
대략 어떤 느낌인지 알았으니 본격적으로 공부해보자.

DFS는 깊이 우선 탐색이라고 부르고 그래프의 깊은 부분을 우선적으로 탐색하는 알고리즘이다.

그래프는 노드와 에지로 표현되고 에지는 간선이라고도 한다.  
예를 들어 서울에서 부산으로 이어진 기찻길이 있고 기차가 다닌다. 여기서 서울, 부산은 노드에 해당하고 기찻길은 간선에 해당한다.

이러한 연결 관계를 어떻게 코드로 표현할 수 있을까?  
크게 두 가지 방법으로 표현한다. 
1. 인접 행렬
2. 인접 리스트

인접 행렬이란 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다. 파이썬에서는 2차원 리스트를 사용한다.  
인접 리스트는 1 -> 2의 관계를 graph[0].append((1, 2))와 같이 저장하고 다시 연관관계가 있는 2->3가 있다고 했을 때, graph[1].append((2, 3))과 같이 저장한다.

DFS는 시작 노드에서 출발해서 한쪽 분기를 정해서 최대 깊이까지 탐색을 마친 뒤 다른 분기로 이동하여 다시 최대 깊이까지 탐색을 하는 것을 반복하는 알고리즘이다.  
기본 코드 형태를 보고 익숙해지자.

우선 계속 뎁스를 심화해가며 탐색하기 때문에 사용할 수 있는 방법은 스택과 재귀가 있다.
만약 스택으로 구현한다면 다음과 같다.
1. 시작 노드를 스택에 삽입하며 방문 리스트에 체크한다.
2. 스택에서 꺼내며 꺼낸 노드를 탐색 순서에 기록한다.
3. 스택에 값이 없을 때 까지 반복한다.

실제로는 스택보단 재귀를 많이 사용한다.  
기본 코드는 다음과 같다.
```py
def DFS(graph, v, visited):
  visited[v] = True
  print(v, end=' ')
  for i in graph[v]:
    if not visited[i]:
      DFS(graph, i, visited)

visited = [False] * 9
start = 1
DFS(graph, start ,visited)
```

DFS알고리즘으로 풀 수 있는 문제는 프로그래머스의 타겟 넘버 문제가 있다.

n개의 정수가 주어지고 순서를 바꾸지 않고 더하거나 빼서 타겟 넘버를 만드는 경우의 수를 구하는 문제다.
```
numbers = [1, 1, 1, 1, 1]
target = 3
```
```
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
```
이렇게 해서 답은 5가 된다. 어떻게 풀 수 있을까?

예를 들어 다음과 같은 그래프가 있다고 해보자.
```
1-2-5
| ㄴ6
3-4-6
```
1. 시작 노드를 스택에 삽입하고 방문 리스트에 기록한다.
2. 스택의 최상단 노드와 인접한 노드가 있다면 그 노드를 스택에 넣고 방문 리스트에 기록한다.
3. 1,2번 과정을 더 이상 수행할 수 없을 때까지 반복한다.

1번과 인접한 인접한 노드는 2, 3번이다. 순서대로 스택에 넣는다.  
방문 리스트에 기록한다.  
가장 상단의 노드는 3이니 3을 꺼낸다. 3의 인접노드는 4이므로 4를 스택에 넣고 뺀 뒤 방문 리스트에 기록한다.  
여기까지 했을 때 방문 리스트에는 1, 2, 3, 4가 체크되어있는 상태다.  
4의 인접노드는 6이므로 6을 스택에 넣고 뺀 뒤 방문 리스트에 기록한다.

스택에 남아있는 노드는 2이고 2의 인접 노드인 5를 넣는다.(6은 이미 방문했으니 제외한다.)  
스택에 5를 넣고 뺀 뒤 방문 리스트에 기록한다.

나머지를 다 제거하고 방문 리스트에 기록하면 끝난다.

기본 코드 형태는 이렇다.  
스택을 사용해도 되지만 재귀 호출을 사용해서 푼 코드다.
```py
def DFS(graph, v, visited):
  visited[v] = True
  print(v, end=' ')

  for i in graph[v]:
    if not visited[i]:
      DFS(graph, i, visited)

graph = [
  [],
  [2, 3],
  [1, 5, 6],
  [1, 4],
  [3, 6],
  [2],
  [2, 4]
]
visited = [False] * 7

DFS(graph, 1, visited)
## 1 2 5 6 4 3
```
1부터 시작한다. 1이 방문 리스트에서 True로 체크되고 인접 리스트를 돌며 만약 방문하지 않았다면 DFS를 실행시킨다. 이와 같은 과정을 반복한다.

탐색 순서는 1 2 5 6 4 3으로 스택으로 풀었을 경우와 순서가 달라진다.

## DFS 문제풀이

### 타겟 넘버

n개의 자연수가 있다. 순서를 바꾸지 않고 더하거나 빼서 타겟 넘버를 만든다. 

예를 들어 [4, 1, 2, 1]이 주어졌다.  
가능한 경우의 수는  
* 4 + 1 -2 + 1 = 4
* 4 -1 + 2 -1 = 4
이렇게 두 가지고 답은 2가된다.

탐색을 거듭하면서 depth를 기록한다. 만약 맨 마지막까지 탐색을 마쳤고 그 값이 타겟과 같다면 answer + 1을 한다.

```의사코드
최대 깊이 = len(주어진 데이터)
def DFS(depth, 결과):
  if 현재 깊이 == 최대 깊이:
    if 결과 == 타겟:
    answer += 1
  else:
    depth += 1
    DFS(depth, 결과 + 데이터[depth])
    DFS(depth, 결과 - 데이터[depth])
```

## BFS

위의 그래프를 다른 방식으로 완전 탐색할 수도 있다.  
가장 가까운 노드부터 탐색하는 방법으로 깊이 우선 탐색과 구분하여 BFS, 너비 우선 탐색이라고 부른다. 얘를 들어 아래의 그래프를 BFS로 탐색하게 된다면 다음과 같다.
```
1-2-5
| ㄴ6
3-4-6
```
1 -> 2 -> 3 -> 5 -> 6 -> 4가 된다.

BFS에는 인접한 노드를 자료구조에 넣으면 먼저 들어온 값이 가장 먼저 나가는 구조인 큐를 사용한다.  
1. 1번 노드를 삽입하고 방문처리한다.  
2. 1을 꺼내고 인접 노드인 2와 3을 넣고 방문처리한다.  
3. 2를 꺼내고 인접노드 5와 6을 넣고 방문처리한다.
4. 3을 꺼내고 인접노드인 4를 큐에 삽입한다.
5. 5와 6의 인접노드는 없으므로 방문 리스트에만 추가하고 큐에 별도의 노드를 삽입하지 않는다.
6. 4를 꺼내며 인접노드를 확인하는데 6은 이미 방문했으므로 큐에 삽입하지 않는다.

BFS의 기본 코드는 이렇다.
```의사코드
너비우선 탐색 함수():
  큐 생성
  방문 배열에 start 노드를 기록
  큐가 모두 빌 때까지:
    큐에서 하나의 요소를 뽑음
    해당 원소와 연결되어있고 아직 방문하지 않은 요소들을 큐에 삽입:
      만약 방문하지 않았다면 큐에 추가하고 방문 처리
```
```py
from collections import deque

def BFS(graph, start, visited):
  queue = deque([start])
  visited[start] = True
  while queue:
    v = queue.popleft()
    print(v, end=' ')
    for i in graph[v]:
      if not visited[i]:
        queue.append(i)
        visited[i] = True

graph = [
  [],
  [2, 3],
  [1, 5, 6],
  [1, 4],
  [3, 6],
  [2],
  [2, 4]
]

visited = [False] * 9
BFS(graph, 1, visited)
## 1 2 3 5 6 4
```

## BFS 문제풀이

### 미로 탈출

N * M의 방이 있다. 이중 갈 수 있는 방은 1, 갈수 없는 부분은 0으로 나타내어지고 2차원 배열로 주어진다.  
시작은 (1,1) 도착은 (N, M)이다.  최단 경로를 구해야한다.
```
1 1 0
0 1 0
0 1 1
```
시작 점부터 상, 하, 좌, 우로 탐색을 한다.  
가장 먼저 (1, 2)에 해당하는 1을 방문하게된다.  
그리고 1, 2의 값을 2로 바꾼다. 2는 현재까지의 경로의 수에 해당한다.  
다음으론 (2, 2)의 위치로 갈 수 있다. 그럼 이전 노드에 저장된 값에서 +1을 해준다.

지금 위치에서 +1에 해당하는 경로로 이동한다. 이동한 다음 좌표의 유효성을 체크한다.  
주어진 맵안에 있는지, 이동할 수 없는 값인지.

이동한 다음 현재까지의 경로 값을 저장한다.

```의사코드
dx 좌, 우
dy 상, 하

BFS(시작 x, y):
  큐 선언
  큐에 시작 좌표 넣기.

  while 큐가 빌 때까지:
    x, y = 큐.popleft()

    for i in range(상하좌우 4):
      좌표 이동
      nx = x + dx[i]
      ny = y + dy[i]

      if 이동한 좌표가 맵 범위 안에 있는지 확인:
        무시
      if 이동한 좌표가 갈 수 있는 곳인지 확인:
        무시
      if 이동한 좌표의 값이 1이라면 아직 한 번도 방문하지 않았으니 로직 실행:
        이동한 좌표의 값은 이전 좌표의 값인 maps[x][y] + 1로 갱신
        큐에 좌표를 넣는다.
  도착 지점의 값 리턴
```
```py
from collections import deque

dx = [1, -1, 0, 0]
dy = [0, 0, -1, 1]

maps = [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]]

def BFS(x, y):
  queue = deque()
  queue.append((x, y))
  
  while queue:
    x, y = queue.popleft()

    for i in range(4):
      nx = x + dx[i]
      ny = y + dy[i]

      if nx < 0 or ny < 0 or nx >= n or ny >= m:
        continue
      if maps[nx][ny] == 0:
        continue
      if maps[nx][ny] == 1:
        maps[nx][ny] = maps[x][y] + 1
        queue.append((nx, ny))
  return maps[-1][-1]

print(BFS(0, 0))
```

완전탐색 문제를 봤을 때 DFS인지 혹은 BFS인지 알 수 있는 방법은 구하려고 하는 경로 값이 어떤 값인지이다.  
예를 들어 위의 문제의 경우 최단 경로를 구하라고 한다.  
이런 상황에선 얕은 depth를 탐색하며 만약 미로를 탈출했다면 그 값을 리턴하고 종료하면 되는 것이다.  
프로그래머스의 게임 맴 최단 거리의 경우 DFS를 사용해서 푼다면 효율성 검사에서 통과하지 못하게 된다.

## BFS 문제 추천

### 게임 맵 최단 거리

![image](https://github.com/jh10253267/TIL/assets/108499717/a557b502-927a-47bf-a6dd-d1a4637becb9)
완전탐색으로 푸는 문제로 DFS혹은 BFS를 사용할 수 있다.

### 미로 탐색

[백준 미로탐색](https://www.acmicpc.net/problem/2178)

### 괄호 변환

