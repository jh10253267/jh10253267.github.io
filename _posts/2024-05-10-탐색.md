---
layout: post
title:  "탐색"
author: 악어새62
categories: [ TIL, Algorithm ]
image: assets/images/2.jpg
tags: [ 파이썬, 코딩테스트 ]
---
## 개요

공부한 걸 내 것으로 만들려면 정리하는 시간이 필요하다!

## 알고리즘 설명

탐색이란 그래프 완전 탐색 기법중 하나로 많은 양의 데이터 중에 원하는 데이터를 찾는 과정을 말한다.

## 사전지식

### 스택

스택이란 창고에 물건을 하나씩 쌓는 것과 같다.  
가장 밑에 있는 물건을 사용하려면 가장 위에있는 것 부터 치워야한다. 이러한 구조를 선입후출이라고 한다.

예를 들어 스택 자료구조에 5,4,3,2,1을 넣고 하나씩 꺼낸다면 1,2,3,4,5의 순서로 출력된다.

파이썬에서는 별도의 라이브러리를 사용하지 않아도 기본 리스트를 사용하면 스택과 동일하게 사용이 가능하다.
* append - 리스트의 가장 마지막에 요소를 추가함
* pop - 리스트의 가장 마지막에서 하나를 반환함

### 큐

큐는 종이컵 디스펜서와 같다. 위쪽에서 종이컵을 넣고 아래쪽에서 종이컵을 꺼내서 쓴다.(굳이 위에서 꺼내쓰는 별난 사람들은 예외로 치자.)  
이런 구조를 선입선출이라고 부른다.

예를 들어 5,4,3,2,1을 넣고 출력한다면 5,4,3,2,1의 순서로 출력된다.

파이썬에서 큐는 collections라이브러리의 deque를 사용한다. 스택과 큐의 장점을 가지고있고 속도가 빠르다.
```python
from collections import deque

queue = deque()

queue.append(5)
queue.append(4)
queue.append(3)
queue.append(2)
queue.append(1)

queue.popleft()
print(queue) # deqye([4,3,2,1])
```

### 재귀

자기 자신을 호출하는 것을 말한다.  
```plain
내가 옛날이야기 하나 해주마
옛날 어느 산에 신선이 살았단다.
그 신선이 말하기를 "내가 옛날 이야기 하나 해주마"
"옛날에 어느 산에 신선이 살았단다"
"그 신선이 말하기를"
...
```

팩토리얼을 생각해도 되겠다.
```python
def factorial(n):
  if n <= 1:
    return 1
  return n * factorial(n-1)

factorial(5) # 120
```

## 문제풀이

### 프로그래머스 이웃한 칸

색깔을 담은 2차원 배열이 주어지고 배열의 특정 인덱스가 주어져서 타겟 칸의 색과 일치하는 색이 상하좌우에 몇 개가 있는지 구하는 문제  
h, w는 각각 y축과 x축에 해당한다.  
board의 길이 즉 행의 갯수는 1보다 크거나 같고 7보다 작거나 같다.  
board의 열의 갯수는 1보다 크거나 같고 10보다 작거나 같다.

즉, y의 길이는 최대 7이고 x의 길이는 최대 10이된다.

* 타겟 색깔을 구한다.
* 타겟 색깔의 칸으로부터 상하좌우를 탐색한다.
* 만약 인덱스가 범위안에 있고 타겟 색과 일치하면 count를 증가시킨다.
```python
def solution(board, h, w):
    answer = 0
    dh = [1, -1, 0, 0] # 상하
    dw = [0, 0, 1, -1] # 좌우
    target = board[h][w]

    for i in range(len(dh)):
      h_check, w_check = h + dh[i], w + dw[i]

      if 0 <= h_check < len(board) and 0 <= w_check < len(board[0]):
        if board[h_check][w_check] == target:
          answer += 1

    return answer
```
주의해야할 점은 for 반복문은 상하좌우 한 칸씩만 이동하기 때문에 len(dh) 혹은 len(dx)를 조건으로 넣어야하고 마지막에 답을 구할 때는 board상의 y인덱스인 h_check와 x인덱스인 w_check가 유효한지 체크해야하기 때문에 board의 가로와 세로 길이를 넣어줘야한다는 것이다.

## DFS

위의 문제는 프로그래머스에서 탐색 문제의 맛보기 식으로 준비한 문제라고 생각한다.  
이처럼 레벨 1문제는 알고리즘을 몰라도 풀 수 있는 문제들이 많고 알고리즘에 대해 찾아보고 공부할 수 있는 문제들이 많다.
대략 어떤 느낌인지 알았으니 본격적으로 공부해보자.

DFS는 깊이 우선 탐색이라고 부르고 그래프의 깊은 부분을 우선적으로 탐색하는 알고리즘이다.

그래프는 노드와 에지로 표현되고 에지는 간선이라고도 한다.  
예를 들어 서울에서 부산으로 이어진 기찻길이 있고 기차가 다닌다. 여기서 서울, 부산은 노드에 해당하고 기찻길은 간선에 해당한다.

이러한 연결 관계를 어떻게 코드로 표현할 수 있을까?  
크게 두 가지 방법으로 표현한다. 
1. 인접 행렬
2. 인접 리스트

인접 행렬이란 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다. 파이썬에서는 2차원 리스트를 사용한다.  
인접 리스트는 1->2의 관계를 graph[0].append((1, 2))와 같이 저장하고 다시 연관관계가 있는 2->3가 있다고 했을 때, graph[1].append((2, 3))과 같이 저장한다.

주로 인접 리스트를 사용하는 것 같다.

DFS는 시작 노드에서 출발해서 한쪽 분기를 정해서 최대 깊이까지 탐색을 마친 뒤 다른 분기로 이동하여 다시 최대 깊이까지 탐색을 하는 것을 반복하는 알고리즘이다.

DFS알고리즘으로 풀 수 있는 문제는 프로그래머스의 타겟 넘버 문제가 있다.

n개의 정수가 주어지고 순서를 바꾸지 않고 더하거나 빼서 타겟 넘버를 만드는 경우의 수를 구하는 문제다.
```
numbers = [1, 1, 1, 1, 1]
target = 3
```
```
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
```
이렇게 해서 답은 5가 된다. 어떻게 풀 수 있을까?


예를 들어 다음과 같은 그래프가 있다고 해보자.
```
1-2-5
| ㄴ6
3-4-6
```
1. 시작 노드를 스택에 삽입하고 방문 리스트에 기록한다.
2. 스택의 최상단 노드와 인접한 노드가 있다면 그 노드를 스택에 넣고 방문 리스트에 기록한다.
3. 1,2번 과정을 더 이상 수행할 수 없을 때까지 반복한다.

1번과 인접한 인접한 노드는 2, 3번이다. 순서대로 스택에 넣는다.  
방문 리스트에 기록한다.  
가장 상단의 노드는 3이니 3을 꺼낸다. 3의 인접노드는 4이므로 4를 스택에 넣고 뺀 뒤 방문 리스트에 기록한다.  
여기까지 했을 때 방문 리스트에는 1, 2, 3, 4가 체크되어있는 상태다.  
4의 인접노드는 6이므로 6을 스택에 넣고 뺀 뒤 방문 리스트에 기록한다.

스택에 남아있는 노드는 2이고 2의 인접 노드인 5를 넣는다.(6은 이미 방문했으니 제외한다.)  
스택에 5를 넣고 뺀 뒤 방문 리스트에 기록한다.

나머지를 다 제거하고 방문 리스트에 기록하면 끝난다.

기본 코드 형태는 이렇다.  
스택을 사용해도 되지만 재귀 호출을 사용해서 푼 코드다.
```py
def DFS(graph, v, visited):
  visited[v] = True
  print(v, end=' ')

  for i in graph[v]:
    if not visited[i]:
      DFS(graph, i, visited)

graph = [
  [],
  [2, 3],
  [1, 5, 6],
  [1, 4],
  [3, 6],
  [2],
  [2, 4]
]
visited = [False] * 7

DFS(graph, 1, visited)
```
1부터 시작한다. 1이 방문 리스트에서 True로 체크되고 인접 리스트를 돌며 만약 방문하지 않았다면 DFS를 실행시킨다. 이와 같은 과정을 반복한다.

탐색 순서는 1 2 5 6 4 3으로 스택으로 풀었을 경우와 순서가 달라진다.