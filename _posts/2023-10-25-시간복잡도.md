---
layout: post
title:  "시간복잡도"
author: 악어새62
categories: [ TIL, Algorithm ]
image: assets/images/4.jpg
tags: [파이썬, 코딩테스트]
---
## 개요

우리가 약속을 잡고 나갈 때 출발 시간을 정하는 기준은 여러가지가 있다.  
이론적으로 언제까지 어디에 도착해야하고 어떤 이동수단을 타면 딱 맞게 도착하겠다.  
여기엔 버스가 늦게올 확률, 무언가를 빼먹어서 다시 집으로 돌아갈 확률 등이 빠져있어서 지각할 때가 많았다...  
내가 늦어서 짜증났던 사람들에게 이 자리를 빌려 심심한 사과의 말씀을 드린다.  

그래서 항상 버스 배차 시간의 최대를 기다리는 시간으로, 목적지까지 가는데 걸리는 시간의 최대를 예상 시간으로 잡고 나간다. 그래야 지각을 안한다.

컴퓨터의 문제 해결 과정도 마찬가지다.  

## 시간복잡도

다음과 같은 배열이 있다고 하자.
```java
int[] a = {1,3,4,5,10,9,8};
```
이 배열에서 특정 숫자를 찾는다면 몇번의 연산을 수행해야 할까?

찾으려는 숫자가 1일 경우 한번만에 찾을 수 있다. -> 최선  
8을 찾으려면 7번의 연산을 통해 찾을 수 있다. -> 최악
 
최선일 때의 연산횟수를 나타내는 표기법은 빅 오메가  
평균의 연산횟수를 나타내는 표기법은 빅 세타  
최악일 때의 연산횟수를 나타내는 표기법은 빅 오

위에서 살펴본 대로 약속장소까지 걸리는 시간을 최단 시간으로 계획을 세우면 빅 오메가, 걸리는 최대 시간으로 계획을 세우면 빅 오에 해당한다.

이중에 코딩테스트에서 참고하는 시간복잡도는 빅 오이다.  
그 이유는 다양한 테스트케이스를 돌려 통과해야만 하는데  
최악의 경우로 문제를 해결했을 때의 예상 시간을 기준으로 알고리즘을 선택해야 모든 테스트케이스를 통과할 수 있다.  
위의 배열의 경우 빅 오 시간복잡도는 자료의 수가 4개일 때 4, 자료의 수가 n개일때는 n이 된다.

코딩테스트에는 시간제한이 있고 사용하는 알고리즘마다 시간복잡도가 다를 수 있다.  
따라서 문제를 맞추더라도 시간복잡도를 염두했을 때 제한시간보다 더 오래 걸린다면 다른 방법을 생각해봐야한다.  
그리고 시간복잡도에서 상수는 무시하는데 이는 무한 급수에서 상수를 무시하는 것과 같은 이유다.  
배열을 병렬적으로 10번 탐색하더라도 시간복잡도는 10n이 아닌 n이 된다.

이진 탐색의 경우 시간 복잡도를 계산해보면 log2(n)이지만 상수는 무시하기 때문에 log(n)이라고 표기한다.  
그리고 for문을 중첩해서 돌린다면 n개의 자료에 대해 각각 n번을 반복하기 때문에 시간복잡도는 n^2이 된다.

아래의 그래프는 시간 복잡도의 종류에 따른 데이터 양과 연산 횟수를 의미한다.
![image](https://github.com/user-attachments/assets/d2475031-54e0-4d98-94c6-6f58aed0bf36)

**`O(1)`**은 상수로 주로 해시 자료구조에서 값을 찾거나 배열의 가장 첫 번째 요소를 찾는 작업의 시간 복잡도에 해당한다. 또는 코딩 문제를 풀면서 데이터를 단순히 사칙연산하여 답을 구할 수 있는 경우도 시간복잡도는 상수이다.

**`O(n)`**은 비례관계로 선형이라고 한다. 데이터 양이 증가함에 따라 메모리 사용, 연산 횟수가 선형적으로 증가한다.

**`O(n^2)`**은 반복문이 중첩되어 2개가 있는 경우로 수학에서의 y = x^2과 같다. 데이터 양이 증가함에 따라 처리 시간은 그의 제곱배로 증가한다.  
만약 반복문이 4개가 중첨되어있는 경우 시간 복잡도는 n^4가 된다.

**`O(log(n))`**은 데이터 양이 많아짐에 따라 연산 횟수가 서서히 느리게 증가한다.