---
layout: post
title:  "최단 거리"
author: 악어새62
categories: [ TIL, Algorithm ]
image: assets/images/4.jpg
tags: [파이썬, 코딩테스트]
---
## 개요

![image](https://github.com/user-attachments/assets/149b9381-0527-4647-93ed-1ac4840abd4e)

위와 같은 그래프가 있다. 그래프는 노드(동그라미)와 간선(선)으로 구성된다.  
1에서 출발해 다른 노드로 가는 최단 거리를 구하려면 어떻게해야할끼? 간선에 표시된 숫자는 거리를 의미한다.

1과 직접적으로 연결된 2, 3, 4노드로가는 최단 거리(비용)은 각각 2, 5, 1이 된다.  
그런 다음 4를 기준으로 생각해보면 4에서 3으로 가는 최단 거리는 3이 된다.  
이렇게 보니 1에서 3으로 직접 가는 비용은 5지만 1에서 4를 거쳐서 3으로 가는 비용은 4로 직접 가는 것 보다 1에서 4를 거쳐서 3으로 가는 것이 최단 거리라는 것을 알 수 있다.

이런식으로 새롭게 거리를 계산해서 최단 경로를 갱신한다면??
각 노드로 가는 최단 거리를 구할 수 있다. 이 것이 바로 다익스트라 알고리즘이다.  
다익스트라 알고리즘은 그리디 알고리즘의 성격을 띈다.  

하나의 라우터에서 다른 라우터로 가는 최단 경로를 찾는 OSPF라우팅 방식에 쓰이는 알고리즘이다.

1. 출발 노드를 정한다.
2. 출발 노드를 기준으로 각 노드의 최소 비용을 기록한다.
3. 방문하지 않은 노드 중에서 가장 비용이 적게드는 노드를 선택한다.
4. 해당 노드를 거쳐서 특정 노드로 가는 경우를 고려해서 최소 비용을 갱신한다.
5. 3 ~ 4번 과정을 반복한다.
예를 들어 위의 그래프에서 각 노드로 가는 최단 거리를 구해보면...

| 1  | 2  | 3 | 4  | 5 | 6 |
|----|----|---|----|----|----|
| 0  | 2  | 5 | 1  | 무한 | 무한 |
| 2  | 0  | 3 | 2  | 무한 | 무한 |
| 5  | 3  | 0 | 3  | 1  | 5  |
| 1  | 2  | 3 | 0  | 1  | 무한 |
| 무한 | 무한 | 5 | 1  | 0  | 2  |
| 무한 | 무한 | 5 | 무한 | 2  | 0  |

1행 4열을 보면 1에서 4로 가는 비용인 1이 기록되어있다.  
현재 방문하지 않은 노드 중 가장 적은 비용이 드는 노드는 4번 노드이다.  
그런 다음 4를 거쳐서 5로 가는 비용은 2가 나오고 이를 최소 비용으로 갱신해준다.  

| 1  | 2  | 3 | 4  | 5 | 6 |
|----|----|---|----|----|----|
| 0  | 2  | 5 | 1  | 2 | 무한 |
| 2  | 0  | 3 | 2  | 무한 | 무한 |
| 5  | 3  | 0 | 3  | 1  | 5  |
| 1  | 2  | 3 | 0  | 1  | 무한 |
| 무한 | 무한 | 5 | 1  | 0  | 2  |
| 무한 | 무한 | 5 | 무한 | 2  | 0  |

다음으로 비용이 적게 드는 노드는 2번 노드이다.  
1 -> 4 -> 2 비용은 3이다.  
이 경우 2로 바로 가는 비용이 2이기 때문에 갱신하지 않는다.

그 다음 방문하지 않은 노드 중에서 가장 적은 비용이 드는 노드는 5번 노드로 1번에서 4번 5번을 거쳐 3으로 가는 경우 비용은 3으로 기존의 비용 5보다 비용이 적다.  
따라서 노드 3으로 가는데 드는 비용을 3으로 갱신한다.  
5를 거쳐서 6으로 가는 경우 비용이 기존의 비용인 무한보다 적다. 따라서 노드 6으로 가는 비용을 4로 갱신한다.

| 1  | 2  | 3 | 4  | 5 | 6 |
|----|----|---|----|----|----|
| 0  | 2  | 3 | 1  | 2 | 4 |

이후 방문하지 않은 노드 중 가장 비용이 저렴한 노드는 3으로 기존 기록된 비용보다 더 많은 비용이 든다. 따라서 갱신하지 않는다.  
마지막으로 노드 6을 방문해도 최단 경로는 갱신되지 않는다.  
이렇게 1번 노드에서 각 노드로 가는 최단 경로를 찾았다.

다익스트라는 O(V^2)의 시간복잡도를 가지며 V는 노드의 갯수를 의미한다.
```python
import sys
input = sys.stdin.readline
# 무한
INF = int(1e9)
# 노드와 간선의 갯수
n, m = map(int, input().split())
start = int(input())

# 노드와 노드에 대한 정보를 기록
graph = [[] for i in range(n + 1)]
visited = [False] * (n + 1)

distance = [INF] * (n + 1)

for _ in range(m):
  a, b, c = map(int, input().split())
  graph[a].append((b, c))

def dijkstra(start):
  distance[start] = 0
  visited[start] = True
  for j in graph[start]:
    distance[j[0]] = j[1]
  for i in range(n - 1):
    now = get_smallest_node()
    visited[now] = True
    for j in graph[now]:
      cost = distance[now] + j[1]
      if cost < distance[j[0]]:
        distance[j[0]] = cost

dijkstra(start)

for i in range(1, n + 1):
  if distance[i] == INF:
    print("INFINITY")
  else:
    print(distance[i])
```

