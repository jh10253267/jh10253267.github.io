---
layout: post
title:  "Gready"
author: 악어새62
categories: [ TIL, Algorithm ]
image: assets/images/1.jpg
tags: [Gready, 알고리즘]
---
## 개요

알고리즘이라고 하면 공식이 떠오른다. 값을 딱 넣으면 알아서 답을 내주는 수학의 수식과 같은 느낌이다.

그러나 알고리즘을 공부하다보면 경험적인 문제 풀이도 존재한다는 걸 알 수 있다. 대표적으로 탐색 알고리즘이 있다.

그리디 알고리즘은 탐욕법이라고도 하며 문제를 단순무식하게 탐욕적으로 푼다고 해서 탐욕법이라는 이름이 붙었다.

> 현재 상황에서 최선의 선택을 한다.

## 설명

그리디 알고리즘을 가장 쉽게 설명할 수 있는 방법은 바로 거스름돈 문제다.

예를 들어 내가 500원, 100원, 50원, 10원짜리 동전을 가지고 있고 충분히 여유있는 갯수로 가지고 있다. 동전 갯수를 최소한으로 써서 넘치지도 않게 부족하지도 않게 정확히 일정 금액을 지불하려고 한다면 어떻게 하는 게 좋을까?

예를 들어 가게에서 3420원을 지불하려한다. 내가 가진 동전은 1원 10원 50원 100원 500원이 있다고 했을 때 동전 갯수를 최소한으로 쓰려면 일단 가장 큰 금액으로 지불할 수 있을 만큼 지불해야한다.

500원이 내가 가진 가장 큰 금액의 동전이므로 500원동전으로만 쓰는게 가장 적게 동전을 쓰는 방법일 것이다.
그러나 500원을 6개 쓰면 부족하고 7개를 쓰면 넘친다.

그러면 500원짜리 동전 6개를 쓰고 그 다음 작은 단위로 넘어가야한다. 그리고도 남으면 더 작은단위로.

이러한 방식을 그리디 알고리즘이라고 한다.
현재 상태에서 보는 선택지중 최선을 선택하고 그 다음 상황에서 또 최선을 선택한다. 그리고 각 상황에서의 최선이 전체의 최선이여야한다.(그리디 알고리즘을 사용할 수 있는 조건)

문제를 푸는 방법은 이렇다. 3420원을 내가 가진 가장 큰 금액의 동전으로 나눈다.
이 경우 6개가 되겠다. 남은 금액은 420원이다.
그 다음은 100원짜리 4개를 쓰고 그 다음은 10원짜리 동전 2개를 쓴다.
이렇게한다면 최소한의 동전만 쓸 수 있다.

의사코드로 표현한다면 다음과 같다.
```java
for(오름차순으로 정렬된 동전 액수의 인덱스를 거꾸로 반복) {
    if(지불 금액보다 동전의 금액이 작으면) {
        동전 수 += 목표금액 / 현재 동전의 금액
        총 금액 = 목표금액 % 현재 동전의 금액.
    }
}
```

코드를 보면 반복문을 돌릴 때 1개의 반복문을 돌리고 있으니 시간복잡도는 O(n)이고 시간 복잡도에 영향을 주는 요소는 금액이 아니라 동전의 종류다.

## 주의점

효과적이고 강력한 알고리즘이지만 모든 문제에 그리디알고리즘을 적용할 수 있는 것은 아니다.

예를 들어 항상 지금 상황에서의 최선을 선택했지만 최적의 해를 찾을 수 없을 수 있다.

따라서 그리디 알고리즘을 사용할 수 있는 조건은 각 상황에서 최적의 해를 찾는 것이 결과적으로 최적의 해를 구하는 것이라는 보장이 있어야한다.

예를 들어 화폐단위가 500원, 400원, 100원이 있고 이를 이용해서 800원을 내야하는 문제가 있다고 해보자.

그리디 알고리즘을 적용한다면 500원을 지불할 것이고 남은 금액인 300원을 100원짜리 3개로 지불할 것이다. 이러면 매 상황에서 최선을 선택한 것이니 정답일 것 같지만 최적의 해는 400원짜리 동전 2개를 내는 것이다.

만약 알고리즘 문제를 푸는데 해결방법이 쉽게 떠오르지 않는다면 그리디알고리즘을 의심해보는 것이 좋다. 만약 이 것도 아니라면 동적 계획법이나 그래프 알고리즘일 확률이 높다.

## 문제풀이

### 기지국

```문제 설명
N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다.

예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다. (전파의 도달 거리가 W일 땐, 기지국이 설치된 아파트를 기준으로 전파를 양쪽으로 W만큼 전달할 수 있습니다.)
```
```입출력 예
N	stations	W	answer
11	[4, 11]	1	3
16	[9]	2	3
```
감으로 만약 시간 복잡도 1로 해결할 수 없다면 경험적으로 찾아야한다는 느낌이 든다.  
이 문제는 그리디 알고리즘 문제로, 스테이션을 순회하면서 전파 범위에 없다면 일단 기지국을 세운다. 전파범위를 최대로 효율적으로 쓰려면 전파 범위 만큼 이동하여 기지국을 세워야한다.

만약 1,2,3,4,5,6과 같이 스테이션이 주어졌다면 첫 번째 기지국은 2번에 세워야한다.  
다음은 이전 전파 범위에서 벗어난 4번부터 확인한다. 만약 중간에 이미 설치된 곳이 있다면 전파범위 밖으로 벗어나서 다시 반복하면 된다.

예제 1번을 보자
1부터 순차적으로 돈다.  
```python
while position <= n:
    position += 1
```
만약 기지국이 없다면 범위가 최대로 되는 지점에 기지국을 설치한다.  
```python
while position <= n:
    answer += 1
    poisition += w + 1 + w
```
이미 다른 기지국의 영향을 받고있는 지점인지 확인해야한다.  
만약 기지국이 설치된 지점이 4라면 4 - w와 현재 위치를 비교하여 만약 이 범위보다 위치가 크가나 같다면 이전 전파범위에 해당한다는 의미이다. 따라서 다음 기지국을 세울 지점은 오른쪽 전파 범위의 다음 위치인 4 + w + 1이 된다.  
만약 아니라면 원래의 시나리오대로 전파범위가 최대가 되는 위치에 기지국을 하나 세운다.
```python
from collections import deque

queue = deque(stations)
...
while position <= n:
    if len(queue) > 0 and queue[0] - w <= position:
        position = queue.popleft() + w + 1
    else:
        answer += 1
        position += w + 1 + w
```
전체코드
```python
from collections import deque

def solution(n, stations, w):
    answer = 0
    queue = deque(stations)

    position = 1
    while position <= n:
        if len(queue) > 0 and queue[0] - w <= position: 
            position = queue.popleft() + w + 1
        else:
            answer += 1
            position += 2 * w + 1

    return answer
```

### 무지의 먹방 라이브

```python
회전판에 먹어야 할 N 개의 음식이 있다.
각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.
무지는 다음과 같은 방법으로 음식을 섭취한다.

무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.
마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.
무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.
다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.
회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.
무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다.
무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.
각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.
```