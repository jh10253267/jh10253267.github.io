---
layout: post
title:  "위상 정렬"
author: 악어새62
categories: [ TIL, WEB, Backend ]
tags: [ ]
image: assets/images/5.jpg
---
## 개요

위상 정렬은 알고리즘을 공부하며 접해본 적이 있는 알고리즘이지만 어떤 상황에서 필요한지에 대한 감이 부족했었다.  
백준에서 1000번 문제부터 차근히 풀어가던 중 ACM Craft라는 문제를 만났고 이 문제와 함께 정리해보려한다.  

## ACM Craft

```
문제
서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.

이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.

 



위의 예시를 보자.

이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할수 있다. (동시에 진행이 가능하다) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번건물의 건설을 시작할수 있다.

따라서 4번건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물과 3번 건물을 동시에 건설하기 시작하면 2번은 1초뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.

프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.

입력
첫째 줄에는 테스트케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다. 첫째 줄에 건물의 개수 N과 건물간의 건설순서 규칙의 총 개수 K이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다) 

둘째 줄에는 각 건물당 건설에 걸리는 시간 D1, D2, ..., DN이 공백을 사이로 주어진다. 셋째 줄부터 K+2줄까지 건설순서 X Y가 주어진다. (이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다) 

마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.

출력
건물 W를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.

건설순서는 모든 건물이 건설 가능하도록 주어진다.

제한
2 ≤ N ≤ 1000
1 ≤ K ≤ 100,000
1 ≤ X, Y, W ≤ N
0 ≤ Di ≤ 100,000, Di는 정수
예제 입력 1 
2
4 4
10 1 100 10
1 2
1 3
2 4
3 4
4
8 8
10 20 1 5 8 7 1 43
1 2
1 3
2 4
2 5
3 6
5 7
6 7
7 8
7
예제 출력 1 
120
39
예제 입력 2 
5
3 2
1 2 3
3 2
2 1
1
4 3
5 5 5 5
1 2
1 3
2 3
4
5 10
100000 99999 99997 99994 99990
4 5
3 5
3 4
2 5
2 4
2 3
1 5
1 4
1 3
1 2
4
4 3
1 1 1 1
1 2
3 2
1 4
4
7 8
0 0 0 0 0 0 0
1 2
1 3
2 4
3 4
4 5
4 6
5 7
6 7
7
```

제일 처음의 건물에서 시작해서 그 다음 건물을 짓는데 선택지가 있다.  
테스트 케이스 1번의 경우는 다음과 같이 나타낼 수 있다.
```
1 -> 2 -> 4
ㄴ3 ----->4 
```
1번 건물을 짓는데 드는 시간은 10초 2번과 3번은 각각 1과 100초. 따라서 1 -> 3 -> 4순서로 건물을 짓는 것 보다 1 -> 2 -> 4순서로 건물을 짓는 것이 빠르다.  
첫번째 경우 120초가 걸리지만 두번째의 경우 21초가 걸린다.  

어떻게 문제를 해결할 수 있을까?

일단 연결 관계를 파악해야한다.  
처음 건물을 큐에 넣는다.  
그런 다음 큐에서 꺼내고 처음 건물과 연결되어있는 간선을 제거한다. 그런 다음 진입 차수가 0인 건물을 큐에 넣는다.
```
1 -> 2 -> 4
ㄴ3 ----->4 
```
```큐
건물 1 
```
```큐
건물 2, 건물 3
```
건물 2를 꺼내고 4를 넣는다.
```큐
건물 4, 건물 3
```
다음 건물 4를 꺼내는데 연결되어있는 간선이 없으므로 넘어간다.  
```큐
건물 3
```
건물 3을 꺼낸다.  
연결되어있는 간선을 제거하면 건물 4가 남으니 건물 4를 큐에 넣는다.
```큐
건물 4
```
입력을 받는 부분
```py
from collections import deque

t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    # 건물 별 걸리는 시간 기록
    d = [0] + list(map(int, input().split()))
    arr = [[] for _ in range(n + 1)]
    # 건물의 차수를 저장
    degree = [0] * (n+1)

    # 입력을 받은 뒤 연결리스트로 연결 정보를 기록하고 차수를 기록한다.
    for _ in range(k):
        x, y = map(int, input().split())
        arr[x].append(y)
        degree[y] += 1
        
    w = int(input())
    
    # 큐 선언
    q = deque()

    # 처음 시작 시 정렬을 시작할 노드를 반복문을 돌며 추가
    for i in range(1, n+1):
        if degree[i] == 0:
            q.append(i)
    # 큐가 전부 빌 때까지 반복
    while q:
        now = q.popleft() 
        # 연결된 건물을 돌며 차수를 감소시킴
        for i in arr[now]:
            degree[i] -= 1
            # 만약 새롭게 차수가 0이된 건물이 있다면 큐에 삽입
            if degree[i] == 0:
                q.append(i) 
```

위와 같은 식으로 연결된 건물들을 연결된 정보대로 순회할 수 있다.  
이와 같은 알고리즘을 위상 정렬이라고 한다.  

만약 교육 커리큘럼이 있고 이들을 정해진 순서대로 들어야한다는 등의 요구 사항이 있다면 위상 정렬을 사용할 수 있다.

이제 문제에 맞춰 다듬어보자.  
시간을 기록해야하니 시간을 기록하는 리스트를 하나 선언해준다.
```py
time = [0] * (n+1)
```

일반적으로 컴퓨터는 시작이 0이다. 리스트나 배열의 첫번째 요소에 접근할 때에도 1이 아닌 0을 사용한다. 그러나 이는 직관적이지 않기 때문에 0번에 해당하는 위치를 사용하지 않고 비워둔 뒤 1번부터 값을 넣는 일종의 트릭을 사용한 것이다.

만약 별도의 조건이 없다면 최소거리를 갱신하며 탐색하면 되겠지만 문제에는 조건이 있다.

1. 앞선 건물이 건설된 다음에 다음 건물의 건설이 시작된다.
2. 진입 차수가 여러개라고 할 때 그 이전의 건물의 건설이 완료되어야 다음 건물을 건설 할 수 있다.

```
1 -> 2 -> 4
ㄴ3 ----->4 
```
1번 건설이 끝난 뒤 4번을 건설하려면 2번과 3번 모두가 완성된 뒤 4번 건물을 지을 수 있다.  
따라서 최소 시간은 가장 건설이 오래걸리는 건물에 달렸다.
```의사코드
인접한 노드를 짓는데 걸리는 시간 = max(현재 건물을 짓는데 필요한 시간 + 인접한 노드를 짓는데 걸리는 시간, 기존에 저장되어있던 시간)
```
위와 같이 표현된다.  
실제 코드로 표현해보면 다음과 같다.
```py
while q:
  now = q.popleft()
  for i in arr[now]:
    degree[i] = -= 1
    time[i] = max(time[now] + d[i], time[i])
    if degree[i] == 0:
      q.append(i)
```

전체 코드는 이렇다
```py
from collections import deque

t = int(input())

for _ in range(t):
    n, k = map(int, input().split())
    # 건물 별 걸리는 시간 기록
    d = [0] + list(map(int, input().split()))
    arr = [[] for _ in range(n + 1)]
    # 건물의 차수를 저장
    degree = [0] * (n+1)

    # 입력을 받은 뒤 연결리스트로 연결 정보를 기록하고 차수를 기록한다.
    for _ in range(k):
        x, y = map(int, input().split())
        arr[x].append(y)
        degree[y] += 1
        
    w = int(input())
    time = [0] * (n+1)
    
    # 큐 선언
    q = deque()

    # 처음 시작 시 정렬을 시작할 노드를 반복문을 돌며 추가가
    for i in range(1, n+1):
        if degree[i] == 0:
            q.append(i)
            time[i] = d[i]

    # 큐가 전부 빌 때까지 반복
    while q:
        now = q.popleft() 
        
        for i in arr[now]:
            degree[i] -= 1
            time[i] = max(time[now] + d[i], time[i])
            if degree[i] == 0:
                q.append(i)

    print(time[w])        
```
결과는 시간초과.  
생각해보면 건물이 100개가 있고 건설을 완료해야하는 w가 10이라면 불필요한 연산이 계속되는 문제가 있다.  
따라서 만약 큐에서 뽑아낸 값이 w와 같다면 더 이상 계산을 할 필요가 없다.

또한 d의 최대 개수가 100,000개 이므로 기본 input으로는 시간이 오래걸린다. 따라서 전에 코딩테스트 팁에서 정리한 것처럼 sys.stdin.readline을 사용해야한다.

시간 초과는 입력값을 받는 시간 때문에 생겼다.  
알고는 있었지만 실제로 겪어보니 신기했다.  
```py
from collections import deque
import sys

input = sys.stdin.readline

t = int(input())

for _ in range(t):
    n, k = map(int, input().split())
    # 건물 별 걸리는 시간 기록
    d = [0] + list(map(int, input().split()))
    arr = [[] for _ in range(n + 1)]
    # 건물의 차수를 저장
    degree = [0] * (n+1)

    # 입력을 받은 뒤 연결리스트로 연결 정보를 기록하고 차수를 기록한다.
    for _ in range(k):
        x, y = map(int, input().split())
        arr[x].append(y)
        degree[y] += 1
        
    w = int(input())
    time = [0] * (n+1)
    
    # 큐 선언
    q = deque()

    # 처음 시작 시 정렬을 시작할 노드를 반복문을 돌며 추가가
    for i in range(1, n+1):
        if degree[i] == 0:
            q.append(i)
            time[i] = d[i]

    # 큐가 전부 빌 때까지 반복
    while q:
        now = q.popleft() 
        
        for i in arr[now]:
            degree[i] -= 1
            time[i] = max(time[now] + d[i], time[i])
            if degree[i] == 0:
                q.append(i)
        if now == w:
          break
    print(time[w])        
```
